from typing import Tuple
import cv2
from cv2 import Mat
import numpy as np
import math


def generate_canny_edge_image(grayImage):
    """
    Convert Image into edge image using canny edge detection
    @param grayImage the gray scale image
    """
    height, width, channels = grayImage.shape
    kernel_size = int(math.sqrt(width * height) / 50)
    kernel_size = kernel_size if kernel_size % 2 else kernel_size - 1

    blur_gray = cv2.GaussianBlur(grayImage, (kernel_size, kernel_size), 0)
    weight = 1/math.log(kernel_size*0.1+1)
    low_threshold = 10 * weight
    high_threshold = low_threshold * 5

    edgeImage = cv2.Canny(blur_gray, low_threshold, high_threshold)

    return edgeImage


def generate_image_with_mask(rawImage: Mat) -> (Tuple[Mat, Mat, Mat]):
    """
    Auto detect the bottom face region as mask using opencv cascade classifier
    Generate edge image using canny edge detection
    and generate input, edge, mask files with mask

    @param rawImage the face image
    @param rawEdgeImage the edge image(black&white lines) generated by canny edge detection
        rawEdgeImage has to be gray scale image
    """

    # Import opencv face cascade classifier to find out the bottom half face
    cascasdepath = "./haarcascade_frontalface_default.xml"
    face_cascade = cv2.CascadeClassifier(cascasdepath)

    # Calculate the position of face
    gray = cv2.cvtColor(rawImage, cv2.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(
        gray,
        scaleFactor=1.2,
        minNeighbors=5,
        minSize=(30, 30)
    )

    # initialize images
    rawEdgeImage = generate_canny_edge_image(rawImage)
    image_input = rawImage
    image_edge = np.ones(rawImage.shape[:2], dtype=np.uint8)*255
    image_mask = np.zeros(rawImage.shape[:2], dtype=np.uint8)

    # Generate images with multiple faces region
    for (x, y, w, h) in faces:
        # Bottom half image
        x = x + w // 2
        w = w // 2
        image_mask[x:x+w, y:y+h] = 255
        image_input[x:x+w, y:y+h] = 255
        image_edge[x:x+w, y:y+h] = rawEdgeImage[x:x+w, y:y+h]

    return image_input, image_edge, image_mask


if __name__ == '__main__':
    # Image path & name
    rawImagePathName = "./ourimage/test_raw.jpg"
    imageBaseName = "test"
    saveFolderPath = "./ourimage/result/"

    # Read images
    rawImage = cv2.imread(rawImagePathName)
    # Process the images
    image_input, image_edge, image_mask = generate_image_with_mask(rawImage)

    # Write the images
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_input.jpg", image_input)
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_edge.jpg", image_edge)
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_mask.jpg", image_mask)
