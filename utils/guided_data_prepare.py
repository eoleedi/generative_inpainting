from typing import Tuple
import cv2
from cv2 import Mat
import numpy as np
import math
import os
pyexecutePath = os.path.dirname(__file__)


def face_detection(image):
    """Face Detection using YuNet"""
    model = f"{pyexecutePath}/face_detection_yunet_2022mar.onnx"
    score_threshold = 0.6
    nms_threshold = 0.3
    backend = cv2.dnn.DNN_BACKEND_DEFAULT
    target = cv2.dnn.DNN_TARGET_CPU
    yunet = cv2.FaceDetectorYN.create(
        model=model,
        config='',
        input_size=(320, 320),
        score_threshold=score_threshold,
        nms_threshold=nms_threshold,
        top_k=5000,
        backend_id=backend,
        target_id=target
    )
    yunet.setInputSize((image.shape[1], image.shape[0]))
    _, faces = yunet.detect(image)  # faces: None, or nx15 np.array

    processed_faces = []
    for face in faces:
        x, y, w, h = face[0:4].astype(np.int32)
        processed_faces.append((x, y, w, h))

    return processed_faces


def generate_canny_edge_image(image):
    """
    Convert Image into edge image using canny edge detection
    @param image the input image
    """
    height, width, channels = image.shape
    kernel_size = int(math.sqrt(width * height) / 50)
    kernel_size = kernel_size if kernel_size % 2 else kernel_size - 1

    blur_gray = cv2.GaussianBlur(image, (kernel_size, kernel_size), 0)
    weight = 1/math.log(kernel_size*0.1+1)
    low_threshold = 10 * weight
    high_threshold = low_threshold * 5

    edgeImage = cv2.Canny(blur_gray, low_threshold, high_threshold)

    return edgeImage


def generate_image_with_mask(rawImage: Mat) -> (Tuple[Mat, Mat, Mat]):
    """
    Auto detect the bottom face region as mask using opencv cascade classifier
    Generate edge image using canny edge detection
    and generate input, edge, mask files with mask

    @param rawImage the face image
    @param rawEdgeImage the edge image(black&white lines) generated by canny edge detection
        rawEdgeImage has to be gray scale image
    """

    # Import opencv face cascade classifier to find out the bottom half face
    cascasdepath = f"{pyexecutePath}/haarcascade_frontalface_default.xml"
    face_cascade = cv2.CascadeClassifier(cascasdepath)

    # Calculate the position of face
    gray = cv2.cvtColor(rawImage, cv2.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(
        rawImage,
        scaleFactor=1.2,
        minNeighbors=5,
        minSize=(30, 30)
    )
    # New method for face detection
    faces = face_detection(rawImage)

    # initialize images
    rawEdgeImage = generate_canny_edge_image(rawImage)
    image_input = rawImage
    image_edge = np.ones(rawImage.shape[:2], dtype=np.uint8)*255
    image_mask = np.zeros(rawImage.shape[:2], dtype=np.uint8)

    # Generate images with multiple faces region
    for (x, y, w, h) in faces:
        # Bottom half image
        y = y + h // 2
        h = h // 2
        image_mask[y:y+h, x:x+w] = 255
        image_input[y:y+h, x:x+w] = 255
        image_edge[y:y+h, x:x+w] = rawEdgeImage[y:y+h, x:x+w]

    return image_input, image_edge, image_mask


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--image', default='', type=str,
                        help='The path of image to be completed.')
    parser.add_argument('--output', default='', type=str,
                        help='The path of folder to be save the result images.')
    args, unknown = parser.parse_known_args()
    # Image path & name
    rawImagePathName = args.image
    imageBaseName = "".join(args.image.split('/')[-1].split('.')[:-1])
    saveFolderPath = args.output

    # Read images
    rawImage = cv2.imread(rawImagePathName)
    # Process the images
    image_input, image_edge, image_mask = generate_image_with_mask(rawImage)

    # Write the images
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_input.jpg", image_input)
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_edge.jpg", image_edge)
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_mask.jpg", image_mask)
