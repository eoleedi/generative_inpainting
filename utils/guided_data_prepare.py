from typing import Tuple
import cv2
from cv2 import Mat
import numpy as np
import math
import os
pyexecutePath = os.path.dirname(__file__)


def generate_canny_edge_image(image):
    """
    Convert Image into edge image using canny edge detection
    @param image the input image
    """
    height, width, channels = image.shape
    kernel_size = int(math.sqrt(width * height) / 50)
    kernel_size = kernel_size if kernel_size % 2 else kernel_size - 1

    blur_gray = cv2.GaussianBlur(image, (kernel_size, kernel_size), 0)
    weight = 1/math.log(kernel_size*0.1+1)
    low_threshold = 10 * weight
    high_threshold = low_threshold * 5

    edgeImage = cv2.Canny(blur_gray, low_threshold, high_threshold)

    return edgeImage


def generate_image_with_mask(rawImage: Mat) -> (Tuple[Mat, Mat, Mat]):
    """
    Auto detect the bottom face region as mask using opencv cascade classifier
    Generate edge image using canny edge detection
    and generate input, edge, mask files with mask

    @param rawImage the face image
    @param rawEdgeImage the edge image(black&white lines) generated by canny edge detection
        rawEdgeImage has to be gray scale image
    """

    # Import opencv face cascade classifier to find out the bottom half face
    cascasdepath = f"{pyexecutePath}/haarcascade_frontalface_default.xml"
    face_cascade = cv2.CascadeClassifier(cascasdepath)

    # Calculate the position of face
    gray = cv2.cvtColor(rawImage, cv2.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(
        rawImage,
        scaleFactor=1.2,
        minNeighbors=5,
        minSize=(30, 30)
    )

    # initialize images
    rawEdgeImage = generate_canny_edge_image(rawImage)
    image_input = rawImage
    image_edge = np.ones(rawImage.shape[:2], dtype=np.uint8)*255
    image_mask = np.zeros(rawImage.shape[:2], dtype=np.uint8)

    # Generate images with multiple faces region
    for (x, y, w, h) in faces:
        # Bottom half image
        y = y + h // 2
        h = h // 2
        image_mask[y:y+h, x:x+w] = 255
        image_input[y:y+h, x:x+w] = 255
        image_edge[y:y+h, x:x+w] = rawEdgeImage[y:y+h, x:x+w]

    return image_input, image_edge, image_mask


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--image', default='', type=str,
                        help='The filename of image to be completed.')
    args, unknown = parser.parse_known_args()
    # Image path & name
    rawImagePathName = f"{pyexecutePath}/../data/ourimage/original/{args.image}"
    imageBaseName = "".join(args.image.split('.')[:-1])
    saveFolderPath = f"{pyexecutePath}/../data/ourimage/prepared/"

    # Read images
    rawImage = cv2.imread(rawImagePathName)
    # Process the images
    image_input, image_edge, image_mask = generate_image_with_mask(rawImage)

    # Write the images
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_input.jpg", image_input)
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_edge.jpg", image_edge)
    cv2.imwrite(f"{saveFolderPath}{imageBaseName}_mask.jpg", image_mask)
